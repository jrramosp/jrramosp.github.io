<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <title>Apuntes de CSS</title>
  <meta name="author" content="Nani" >
  <meta name="description" content="Es una página de apuntes sobre CSS">
  <link rel="shorcut icon" href="favicon.ico" type="image/x-icon">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link href="css/css-style.css" rel="stylesheet">
</head>
<body>
  <h1>Apuntes de CSS en GITHUB</h1>
  <h2>Apuntes tomados de la web de MDN. 1ª Parte</h2>
  <p><a href="index.html">HTML</a>-<a href="css-segunda.html">CSS 2ª parte &gt;&gt; </a></p>
  <p>Hay tres formas de aplicar estilos CSS en una página web:</p>
  <ul>
    <li>Como un enlace externo añadido en la cabecera del documento con <code>link rel="stylesheet"
    href="style.css"</code>.</li>
    <li>En la cabecera del documento entre las etiquetas <code>style</code>.</li>
    <li>Dentro de una etiqueta con la forma <code>style="color:red;"</code></li>
  </ul>
  <p>La principal función del lenguaje CSS es asignar valores a las propiedades CSS. Las reglas en CSS son definidas
    por un selector más un bloque de declaraciones. Y un bloque de declaraciones viene definido por propiedades y sus
  valores.</p>
  <p>Además de las reglas estandar, podemos encontrar las reglas específicas. Comienzan con el símbolo (@), seguido del
  identificador del tipo de regla.</p>
  <p>Los comentarios en CSS comienzan con /* y acaban con */.</p>
  <p>Algunas propiedades como: <code>font</code>, <code>background</code>, <code>padding</code>, <code>border</code>, y
    <code>margin</code> se llaman propiedades abreviadas — permiten establecer varios valores a la vez en una sola
  línea.</p>
  <p>Podemos dividir los selectores en las siguientes categorías:</p>
  <ul>
    <li><strong>Selectores simples</strong>: Seleccionan los elementos por el nombre del tipo de elemento, class, o su id.
    <ul> 
     <li> <p><strong>Selectores de elementos</strong> son aquellos que hacen referencia a una etiqueta HTML</p>
      <pre><code>
        p {
          color: red;
        }
        </code></pre>
    </li>
    <li>
      <p>El <strong>selector de clase</strong> se forma con un punto, '<code>.</code>', seguido de un nombre de clase. Un nombre de
      clase puede ser cualquier valor sin espacios usado dentro de un atributo HTML <code>class</code>.</p>
      <pre><code>
        .first {
          font-weight: bold;
        }
        </code></pre>
    </li>
    <li>
      <p><strong>El selector ID</strong> está formado por una almohadilla (<code>#</code>), seguida del nombre ID de determinado
      elemento. Cualquier elemento solo puede tener un único nombre ID fijado con el atributo <code>id</code>.</p>
      <pre><code>
        #polite {
          font-family: cursive;
        }
        </code></pre>
    </li>
    <li>
      <p>El <strong>selector universal</strong> (<code>*</code>) es el comodín. Nos permite seleccionar todos los elementos de una
      página.</p></li>
    </ul>
      <p>En CSS, podemos combinar varios selectores juntos y con ello seleccionar elementos contenidos en otros
      elementos, o elementos adyacentes a otros. Disponemos de cuatro tipos:</p>
      <ul>
        <li>El <strong>selector descendiente</strong> — (espacio) — permite seleccionar un elemento anidado en alguna parte dentro de
        otro elemento (no tiene por qué ser un hijo; puede ser un nieto, por ejemplo).</li>
          <pre><code>
    section p {
          color: blue;
        }
    </code></pre>
        <li>El <strong>selector hijo</strong> — &gt; — permite seleccionar un elemento que es hijo directo de otro elemento.</li>
          <pre><code>
    section &gt; p {
          background-color: yellow;
        }
    </code></pre>
        <li>El <strong>selector hermano</strong> — + — permite seleccionar un elemento que es hermano directo de otro elemento (a la
        derecha por ejemplo, en el mismo nivel jerárquico).</li>
          <pre><code>
    h2 + p {
          text-transform: uppercase;
        }
    </code></pre>
        <li>El <strong>selector hermano</strong> en general — ~ — permite seleccionar cualquier elemento hermano de otro (por ejemplo en
        el mismo nivel jerárquico, pero no necesariamente adyacente a él).</li>
    <pre><code>
    h2 ~ p {
          border: 1px dashed black;
        }
    </code></pre>
      </ul>
    </li>
    <li><strong>Selectores de atributos</strong>: Seleccionan los elementos por los valores de sus atributos.</li>

      <p>Estos selectores de atributos afectarán a los elementos cuyo valor coincida exactamente con el valor del
      atributo especificado:</p>
      <ul>
        <li><code>[attr]</code> : Este selector 'seleccionará' todos los elementos que contengan el atributo
        <code>attr</code>, sin importar el valor que tenga.</li>
        <pre><code>
        /* Todos los elementos con el atributo "data-vegetable"
	serán texto verde */
	[data-vegetable] {
	  color: green;
	}
        </code></pre>
        <li><code>[attr=val]</code> : Este, seleccionará los elementos con el atributo <code>attr</code>, pero solo
        aquello cuyo valor coincida con <code>val</code>.</li>
        <pre><code>
        /* Todos los elementos con el atributo "data-vegetable"
	   con el valor exacto "liquid" tendrán fondo dorado */
	[data-vegetable="liquid"] {
	  background-color: goldenrod;
	}
        </code></pre>
        <li><code>[attr~=val]</code>: Este selector afectará a los elementos con el atributo <code>attr</code>, pero
        solo si el valor <code>val</code> está contenido en la lista de valores (separados por espacios) incluidos en
        el valor de <code>attr</code>, por ejemplo una de las clases contenida en una lista de clases (separadas por
        espacios).</li>
        <pre><code>
        /* Todos los elementos con el atributo "data-vegetable",
	   que contenga el valor "spicy", incluso entre otros,
	   serán de texto rojo */
	[data-vegetable~="spicy"] {
	  color: red;
	}
        </code></pre>
      </ul>
      <p><strong>Selector de atributos por valor textual</strong>, parecidos a las regexp</p>
    <ul>
      <li><code>[attr|=val]</code> : Este selector elegirá todos los elementos con el atributo <code>attr</code> cuyo valor sea exactamente <code>val</code> o empieza por <code>val-</code> (nota: el guion no es un error, se usa para manejar códigos de lenguaje de programación).</li>
      <pre><code>
      /* Uso clásico para selección de idioma */
      [lang|=fr] {
        font-weight: bold;
      }  
      </code></pre>
      <li><code>[attr^=val]</code> : Seleccionará todos los elementos cuyo atributo <code>attr</code> comienza por el valor <code>val</code>.</li>
      <pre><code>
      /* Todos los elementos con el atributo "data-quantity", para los cuales
         el valor comience con "optional" */
      [data-quantity^="optional"] {
        opacity: 0.5;
      }  
      </code></pre>
      <li><code>[attr$=val]</code> : Este selector elegirá todos los elementos cuyo atributo <code>attr</code> termina por el valor <code>val</code>.</li>
      <pre><code>
      /* Todos los elementos con el atributo "data-quantity", para los cuales
         el valor termina con "kg" */
      [data-quantity$="kg"] {
        font-weight: bold;
      }
      </code></pre>
      <li><code>[attr*=val]</code> : Este seleccionará todos los elementos cuyo atributo <code>attr</code> contiene la cadena <code>val</code> (al contrario que <code>[attr~=val]</code>, este selector no considera los espacios como separador de valores sino como parte del valor del atributo).</li>
      <pre><code>
      /* Todos los elementos con el atributo "data-vegetable" que contiene
         el valor "not spicy" se vuelven verdes */
      [data-vegetable*="not spicy"] {
        color: green;
      }  
      </code></pre>
    </ul>
    <li><strong>Pseudo-clases</strong>: Seleccionan los elementos por el estado en que se encuentran, cómo haber aparecido al pasar el
    ratón, o el tic deshabilitado o seleccionado, o por ser el primer hijo de su padre en el árbol DOM.</li>
    <p>Una pseudo-clase CSS consta de una clave precedida de dos puntos (<code>:</code>) que añadiremos al final del selector para indicar que daremos estilo a los elementos seleccionados solo cuando estos se encuentren en un estado determinado.</p>
    <pre><code>
      /* Resaltar el enlace cuando el ratón está
       sobre el enlace (ratón), cuando está activo
       o en el foco (teclado) */
       
    a:hover,
    a:active,
    a:focus {
      color: darkred;
      text-decoration: none;
    } 
    </code></pre>
    <li><strong>Pseudo-elementos</strong>: Selecciona los elementos por su situación en relación a otro elemento, por ejemplo: la
    primera palabra de cada párrafo, o el contenido que se encuentra justo después de un elemento.</li>
    <p>Los pseudo-elementos son parecidos a las pseudo-clases, con alguna diferencia. Estos son claves — ahora precedidas por (<code>::</code>) — que se añaden al final del selector para elegir cierta parte de un elemento.</p>
    <pre><code>
      /* Todos los elementos con el atributo "href", cuyos valores
      empiezan por "http", se añadirá una flecha después de su contenido
      (para indicar que se trata de un enlace externo). */

    [href^=http]::after {
      content: '⤴';
    }
    </code></pre>
    <li><strong>Combinaciones</strong>: No son en sí mismos selectores, sino formas de combinar dos o más selectores de forma práctica
    para una selección especial. Por ejemplo, se pueden seleccionar párrafos que sean descendientes de divs, o párrafos
    situados justo después de títulos.</li>
    <br>
    <ul>
      <li><code>A, B</code>  Cualquier elemento seleccionado por A y/o B (ver Varios selectores en una regla, más adelante).</li>
      <li><code>A B</code>   Cualquier elemento seleccionado por B descendiente de un elemento seleccionado por A (o sea, un hijo, un hijo de otro hijo, etc.).</li>
      <li><code>A > B</code>   Cualquier elemento seleccionado por B y es hijo directo de un elemento seleccionado por A.</li>
      <li><code>A + B</code>   Cualquier elemento seleccionado por B y es el siguiente hermano de un elemento seleccionado por A (o sea, el siguiente hijo del mismo padre).</li>
      <li><code>A ~ B</code>   Cualquier elemento seleccionado por B y es uno de los siguientes hermanos del elemento seleccionado por A (uno de los siguientes hermanos del mismo padre).</li>
    </ul>
    <br>
    <li><strong>Selectores múltiples</strong>: Tampoco son selectores en sí mismos; podemos agrupar múltiples selectores en la misma
    regla CSS separados por comas, para aplicarlos a una de las declaraciones o a todos los elementos seleccionados por
    estos selectores.</li>
    <pre><code>
      h1, h2, h3, h4{
      color:blue
    }
    </code></pre>
  </ul>
  <p>En cuanto a la <strong>unidades de medida</strong> y los valores de ciertas propiedades tenemos:</p>
  <ul>
    <li><strong>Valores numéricos</strong>: Valores de longitud para expresar el ancho de elementos, de bordes, o tamaño de fuentes; también enteros sin unidades para expresar anchos de línea o veces que se repite una animación.</li>
    <p>Como <strong>unidades absolutas</strong>:</p>
    <ul>
    <li>píxeles (px) como unidades absolutas pues siempre tienen el mismo tamaño independientemente de cualquier otra medida.</li>
    <li>mm, cm, in: Milímetros, centímetros, o pulgadas.</li>
    <li>pt, pc: Puntos (1/72 de una pulgada) or picas (12 puntos.)</li>
    </ul>
    <p>Como <strong>unidades relativas</strong>:</p>
    <ul>
    <li>em: 1em es el tamaño de fuente del elemento actual (es el ancho de la letra M mayúscula). El tamaño de fuente por defecto que los navegadores usan antes de aplicar CSS es de 16 píxeles, lo que significa que este es el valor asignado por defecto a un elemento (1em). Ojo — los tamaños de fuente de los elementos se heredan de los padres, por lo que si a los padres se les aplica otros tamaños de fuente, la equivalencia en pixel de un em puede complicarse.</li>
    <li>ex, ch: Son respectivamente la altura de la x minúscula, y el ancho del número 0. Aunque no son tan soportadas por los navegadores como los ems.</li>
    <li>rem: (em raiz) funciona igual que em, excepto que esta siempre igualará el tamaño del tamaño de fuente por defecto; los tamaños de fuente heredados no afectan, por lo que parece mejor solución que ems, rem no funciona en versiones antiguas de Internet Explorer (ver navegadores soportados en Depurando CSS.)</li>
    <li>vw, vh: Estas son respectivamente 1/100 del ancho de la ventana, y 1/100 de la altura de la ventana. Tampoco son tan soportadas como los rems.</li>
    </ul>
    <li><strong>Porcentajes</strong>: Se usan para expresar tamaño o longitud — relativos por ejemplo al ancho y alto del contenedor previo o al tamaño de fuente predeterminado.</li>
    <li><strong>Colores</strong>: Para expresar colores de fondo, de texto, etc.</li>
    <ul>
        <li><strong>Palabras clave</strong>: red, blue, aqua ...</li>
        <li><strong>Valores Hexadecimales</strong>: Cada valor hex está compuesto por una almohadilla (#) seguida por seis números hexadecimales, cada uno de los cuales puede estar comprendido entre el 0 y la f (que representa el 15) — 0123456789abcdef (16 símbolos). Cada par de valores representa uno de los canales primarios — rojo, verde y azul — y nos permite referenciar cualquiera de los 256 valores disponibles para cada uno (16 x 16 = 256). </li>
        <li><strong>Valores RGB</strong>: Un valor RGB es una función — rgb() — a la que pasamos tres parámetros que representas los colores primarios rojo, verde y azul, parecido al sistema hex. La diferencia radica en que, en lugar de representar cada canal por un par de números, ahora lo hacemos simplemente por un número decimal entre el 0 y el 255.</li>
        <li><strong>Valores HSL</strong>:  en vez de valores rojo, verde y azul, la función hsl() admite los valores tono(hue), saturación y brillo (lightness), para referenciar 16,7 millones de colores, pero de forma diferente:</li>
        <ul>
          <li>hue (tono): Es el color básico. Toma un valor entre 0-360, como los ángulos de una rueda de color.</li>
          <li>saturación: ¿Cómo está el color de saturado? Con valores entre 0 y 100%, en 0 no hay color (aparece como una sombra gris), y 100% es la saturación total del color.</li>
          <li>lightness (brillo): Representa la claridad del color. Toma valores entre 0 y 100%, donde 0 es la ausencia de luz (completamente negro) y 100% es el brillo total (completamente blanco).</li>
        </ul>
        <li><strong>Valores RGBA y HSLA</strong>: RGB y HSL tienen sus correspondientes modos — RGBA and HSLA — que nos permiten representar, no solo el color, sino también la transparencia a representar. Sus funciones correspondientes toman los mismos parámetros, más un cuarto valor entre 0–1 — que establece la transparencia, o el llamado canal alfa. 0 es totalmente transparente y 1 completamente opaco.</li>
        <li> Propiedad <code>opacity</code>: Existe otra forma de especificar la transparencia vía CSS — la propiedad <code>opacity</code>. En lugar de fijar la transparencia de un determinado color, aquí fijamos la transparencia de todos los elementos seleccionados y sus hijos. </li>
      </ul>
    <li><strong>Coordenadas</strong>: Para expresar la posición relativa de un elemento desde, por ejemplo, el margen superior izquierdo de la pantalla.</li>
    <li><strong>Funciones</strong>: Para expresar imágenes de fondo o el degradado de la imagen de fondo.</li>
    <pre><code>
      /* calcular la nueva posición de un elemento después de que ha sido rotado 45 grados */
      transform: rotate(45deg);
      /* calcular la nueva posición de un elemento después de que han sido movidos horizontalmente 50px y
      hacia bajo 60px */
      transform: translate(50px, 60px);
      /* calcular el valor del 90% de la anchura actual menos 15px */
      width: calc(90%-15px);
      /* obtener una imagen de la red para utilizarla como imagen de fondo */
      background-image: url('myimage.png');
    </code></pre>
  </ul>
  <p><strong>CSS (Cascading Style Sheets)</strong> ya nos indica que cascada es un concepto importante. A su nivel más básico indica que el orden de las reglas CSS importa, pero es algo más que eso. Que prevalezcan unos selectores sobre otros en la cascada depende de tres factores (en orden de importancia — los primeros prevalecen sobre los últimos):</p>  
  <ol>
    <li><strong>Importancia.</strong> En CSS, hay un trozo de sintaxis que podemos usar para asegurarnos que una determinada regla siempre "gane" sobre todas las demás: <code>!important</code>.</li>
    <li><strong>Especificidad.</strong>La especificidad que tiene un selector se mide mediante 4 valores (o componentes) diferentes, podemos pensar en ellos como en 4 columnas de unidades de millar, centenas, decenas y unidades:
    <ol>
    <li>Unidades de millar: Puntúa 1 en esta columna si la declaración está dentro de un atributo style (como las declaraciones que no tienen selectores, que su especificidad es siempre 1000). Sino puntúa 0.</li>
    <li>Centenas: Puntúa 1 en esta columna por cada selector ID contenido en el selector.</li>
    <li>Decenas: Puntúa 1 en esta columna para cada selector de clase, selector de atributo o de pseudo-clase contenidos en el selector.</li>
    <li>Unidades: Puntúa 1 en esta columna por cada selector de elemento o pseudo-elemento contenidos en el selector.</li>
  </ol>
</li>
    <li><strong>Orden del código.</strong>Las últimas reglas prevalecen sobre las primeras. </li>
  </ol>
  <p>CSS dispone de tres valores especiales para manejar las herencias:</p>
  <ul>
    <li><code>inherit</code> : Este valor establece el valor de la propiedad de un elemento seleccionado en el mismo que su elemento padre.</li>
    <li><code>initial</code> : Este valor establece el valor de la propiedad de un elemento seleccionado en el valor por defecto que establece la hoja de estilos del navegador, si este no existe, la propiedad se hereda naturalmente, adoptando el valor de inherit.</li>
    <li><code>unset</code> : Este valor reestablece la propiedad a su valor natural, esto es: si la propiedad se hereda de forma natural entonces actuará como inherit, sino, actuará como initial.</li>
  </ul>
  <p><strong>Modelos de caja</strong>: Cualquier elemento contenido en un documento tiene la estructura de una caja rectangular dentro del formato del documento.</p>
  <img src="images/box-model.png" alt="Esquema de cajas">

  <p>Las propiedades importantes son:</p>
  <ul>
    <li><strong>width y height</strong>

    Las propiedades <code>width</code> y <code>height</code> establecen el ancho y alto de la caja de contenido, que es el área donde se muestra el contenido de la caja — este contenido comprende tanto el texto incluido en la caja como otras cajas representadas por elementos anidados.<br>

    Nota: Hay otras propiedades que permiten el manejo refinado del tamaño de la caja de contenido — para limitar los tamaños. Para ello se usan las propiedades <code>min-width</code>, <code>max-width</code>, <code>min-height</code>, y <code>max-height</code>.
    </li><br>

    <li><strong>padding</strong>

    Padding hace referencia al margen interior de la caja CSS — entre el límite exterior de la caja del contenido y el límite interior del borde. El tamaño de esta capa puede configurarse en sus cuatro lados a la vez con la propiedad abreviada <code>padding</code>, o cada lado por separado con las propiedades: <code>padding-top</code>, <code>padding-right</code>, <code>padding-bottom </code>y <code>padding-left</code>.
    </li><br>
    
    <li><strong>border</strong>
    El borde de una caja CSS descansa entre el límite exterior del padding y el límite interior del margen. Por defecto tiene un tamaño de 0 — invisible — pero podemos cambiar su grosor, estilo y color para hacerlo visible. La propiedad abreviada de border permite establecer los cuatro lados a la vez, por ejemplo: <code>border: 1px solid black</code>. Pero también se puede dividir en varias propiedades extendidas para su uso en necesidades concretas de estilo:
  	<ul>
      <li><code>border-top</code>, <code>border-right</code>, <code>border-bottom</code>, <code>border-left</code>: Establecen el grosor, estilo y color de cada lado del borde.</li>
      <li><code>border-width</code>, <code>border-style</code>, <code>border-color</code>: Establecen únicamente el grosor, el estilo y el color por separado, pero para los cuatro lados del borde al mismo tiempo.</li>
      Podemos también establecer cada propiedad por separado para cada lado individualmente, usando <code>border-top-width</code>, <code>border-top-style</code>, <code>border-top-color</code>, etc.
    </ul> 
    </li><br>
    <li><strong>margin</strong>

    El margen envuelve la caja CSS, y sostiene a otras cajas del diseño. Se comporta como padding; la propiedad abreviada es margin y las propiedades individuales son <code>margin-top</code>, <code>margin-right</code>, <code>margin-bottom</code>, y <code>margin-left</code>.
    </li>
  </ul>
  <p>El ancho total de una caja se corresponde con la suma de sus propiedades <code>width</code>, <code>padding-right</code>, <code>padding-left</code>, <code>border-right</code>, y <code>border-left</code>.En algunos casos esto es molesto (supongamos que queremos una caja con un ancho total del 50% y el borde y el padding están expresados en pixels). Para evitar estos inconvenientes, podemos modificar el modelo de cajas con la propiedad <code>box-sizing</code>. Con el valor <code>border-box</code>, se cambia el modelo de cajas por este otro:</p>
  <img src="images/box-model-alt.png" alt="Modelo alternativo de caja">
  <p>Otras propiedades para cambiar el comportamiento en el modelo de caja.</p>
  <ul>
  <li><p><strong>Desbordamiento</strong>: Al establecer el ancho de una caja con valores absolutos (p.ej. ancho/alto en pixels), el contenido puede no encajar con el tamaño permitido, en cuyo caso el contenido desborda la caja. Para controlar lo que ocurre en estos casos, podemos usar la propiedad <code>overflow</code>. Puede tomar varios valores, pero los más usuales son:</p></li>
	<ul>
    <li><code>auto</code>: Si hay demasiado contenido, el desbordamiento del contenido es ocultado apareciendo las barras de desplazamiento para permitir al usuario desplazarse para ver todo el contenido</li>
    <li><code>hidden</code>: Si hay demasiado contenido, el desbordamiento es escondido.</li>
    <li><code>visible</code>: Si hay demasiado contendido, el desbordamiento se muestra fuera de la caja (este es normalmente el comportamiento por defecto).</li>
	</ul>
	<li><p><strong>Límite del fondo</strong>: Los fondos de las cajas están hechos de colores e imágenes, apiladas unas sobre otras (<code>background-color</code>, <code>background-image</code>.) Se aplican al fondo de la misma. Por defecto los fondos se extienden hasta el límite exterior del borde. Suele ser suficiente, pero en ocasiones puede molestar (¿Qué pasa si tenemos una imagen de fondo que queremos que solo llegue hasta el límite del contenido?) Este comportamiento puede ajustarse mediante la propiedad <code>background-clip</code> de la caja. Con los valores <code>border-box</code>, <code>padding-box</code> y <code>content-box</code>.</p></li>
	<li><p><strong>Contorno</strong>: Por último, el <code>outline</code> (contorno) de una caja es algo que se parece al borde pero que no forma parte de la caja. Se comporta como el borde pero se dibuja por encima de caja sin cambiar su tamaño (concretando, el contorno se dibuja por fuera de la caja del borde, dentro del área del margen).</p></li>
	</ul>
	<p>El tipo de caja aplicada a un elemento se controla por la propiedad <code>display</code>. Hay muchos valores diferentes para <code>display</code>, pero ahora nos centraremos en los tres más comunes: <code>block</code>, <code>inline</code>, y <code>inline-block</code>.</p>	
	<ul>    
    <li>Una caja <code>block</code> se caracteriza por ser una caja apilada sobre otras cajas (p.ej. el contenido anterior y posterior a la caja aparece en líneas separadas), y puede tener asignada un ancho y un alto. Todo el modelo de cajas descrito anteriormente se refiere a las cajas bloque.</li>
    <li>Una caja <code>inline</code> (de línea) es lo contrario de la caja bloque: Se aplica a los documentos de texto (p.ej. aparecerá en la misma línea rodeando al texto y a otros elementos en la línea, y su contenido avanzará con el texto, como la separación entre las líneas de un párrafo). El ancho y alto definidos no afectan a este tipo de cajas <code>inline</code>; cualquier padding, margen y borde aplicado a las cajas <code>inline</code> modificará la ubicación del texto alrededor, pero no la posición de las cajas (de bloque) circundantes.</li>
    <li>Una caja <code>inline-block</code> es algo intermedio entre las dos primeras: fluye con el texto sin crear líneas de ruptura delante y detrás como las cajas inline, pero puede limitarse estableciendo alto y ancho manteniendo así la integridad de bloque como las cajas block — no se partirá entre las líneas del párrafo (en el anterior ejemplo la caja inline va encima de la 2da línea de texto, al no haber suficiente espacio para ella en la primera línea, y esta no parte las dos líneas).</li>
    </ul>
	<p>Por defecto, los elementos de bloque tiene definido <code>display: block</code>; y los elementos de línea: <code>display: inline</code>.</p>
	<p>Para validar un código CSS tenemos <a href="http://jigsaw.w3.org/css-validator/">el enlace de la W3C</a></p>
	<p><a href="index.html">HTML</a>-<a href="css-segunda.html">CSS 2ª parte &gt;&gt; </a></p>
</body>
</html>
