<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Tipos de sistemas de archivo</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="styles.css" type="text/css">
</head>
<body>
  Un sistema de archivos sirve para rastrear archivos y su almacenamiento en un disco. Sin un sistema de archivos,
  el sistema operativo no sabría cómo organizar los archivos. Para Windows, usamos el sistema de archivos NTFS;
  para Linux, se recomienda usar ext4. Los sistemas de archivos tienen diferentes compatibilidades con distintos
  SO. La mayor parte del tiempo, el soporte inter-SO es mínimo en el mejor de los casos.<br>
  Por suerte, hay sistemas de archivos como FAT32 que admiten lectura y escritura de datos en los tres sistemas
  operativos principales. FAT32 tiene algunas deficiencias, sin embargo. No admite archivos cuyo tamaño supere los
  4 GB y el tamaño del sistema de archivos no puede superar los 32 GB.<br>
  <a href=
  "https://support.microsoft.com/en-us/help/154997/description-of-the-fat32-file-system">https://support.microsoft.com/en-us/help/154997/description-of-the-fat32-file-system</a><br>

  <a name="h3-1" id="h3-1"></a>
  <h3><strong>Anatomía del disco</strong></h3>
  Un disco de almacenamiento se puede dividir en algo llamado particiones. Una partición es sólo una parte del
  disco que puedes administrar. Cuando creas múltiples particiones, te da la ilusión de estar dividiendo
  físicamente un disco en discos separados.<br>
  Para incorporar un sistema de archivos a un disco, primero necesitas crear una partición. Por lo general, solo
  tenemos una sola partición para nuestro sistema operativo, pero no es raro tener múltiples particiones para
  diferentes usos.<br>
  También puedes incorporar diferentes sistemas de archivos en diferentes particiones del mismo disco. Las
  particiones funcionan básicamente como sus propios sub discos separados, pero todas usan el mismo disco físico.
  Algo para señalar es que cuando formateas un sistema de archivos en una partición, se convierte en un
  volumen.<br>
  El otro componente de un disco es una tabla de particiones. Una tabla de particiones le indica al SO cómo se
  particiona el disco. Hay dos esquemas principales de tablas de particiones en uso: MBR, o registro de arranque
  maestro, y GPT, o tabla de particiones GUID.<br>
  MBR es una tabla de particiones tradicional, y se usa principalmente en el SO Windows. MBR solo te permite tener
  volúmenes de hasta 2 TB de tamaño. También usa algo llamado particiones primarias. Solo puedes tener cuatro
  particiones primarias en un disco. Si quieres agregar más, tienes que tomar una partición primaria y convertirla
  en algo que se conoce como partición extendida. Dentro de la partición extendida, puedes hacer algo llamado
  partición lógica.<br>
  GPT se está convirtiendo en el nuevo estándar para discos. Puedes tener un volumen cuyo tamaño supere los 2 TB y
  solo tiene un tipo de partición. Puedes hacer tantas particiones como quieras en un disco. En una lección
  anterior, conocimos un nuevo estándar de BIOS, llamado UEFI, que se convirtió en el BIOS predeterminado para
  sistemas más nuevos. Para poder iniciar con UEFI, tu disco tiene que usar la tabla de particiones GUID.<br>
  <a name="h3-2" id="h3-2"></a>
  <h3><strong>Windows: partición de disco y formateo de un sistema de archivos</strong></h3>
  Windows realmente viene con una gran herramienta nativa, la utilidad de Administración de discos. La iniciaremos
  haciendo clic derecho en This PC (Este equipo), luego seleccionamos la opción Manage (Administrar), y luego
  hacemos clic en la consola Disk Management (Administración de discos) debajo del grupo de almacenamiento.<br>
  Una vez insertada la unidad y que el servicio plug and play se tome el trabajo de instalar el controlador para
  ello, deberías verla aparecer en la administración de discos como un disco adicional. Actualmente, la unidad USB
  está formateada con el sistema de archivos FAT32. Sigamos adelante y reformateamos la partición usando NTFS en
  su lugar. Para esto, hacemos clic derecho en la partición y elegimos el formato.<br>
  Desde esta ventana, podemos elegir la etiqueta de volumen o el nombre que nos gustaría darle al disco. Vamos a
  quedarnos con "USB DRIVE" (unidad USB). También puedes especificar el sistema de archivos, que cambiaremos a
  NTFS. ¿Qué es eso de "Allocation unit size" (Tamaño de unidad de asignación)? Bueno, el tamaño de la unidad de
  asignación es el tamaño de bloque que se usará al formatear la partición en NTFS. En otras palabras, este es el
  tamaño de los fragmentos en los que se dividirá la partición. Los datos que se deben guardar se distribuirán en
  esos fragmentos. Esto significa que si almacenas muchos archivos pequeños, desperdiciarás menos espacio con
  bloques de tamaño pequeño. Si almacenas archivos grandes, bloques de mayor tamaño implicarán que necesites leer
  menos bloques para ensamblar el archivo. También verás que está disponible la opción de realizar un formato
  rápido. La diferencia entre un formato rápido y un formato completo es que en un formato completo, Windows hará
  un poco de trabajo adicional para escanear el disco, o la unidad USB en nuestro caso, en busca de errores o
  sectores defectuosos. La última opción en la pantalla de formato es si se habilita o no la compresión de
  archivos o carpetas. La decisión de habilitar o deshabilitar la compresión acarrea pros y contras. Si habilitas
  la compresión, tus archivos y carpetas ocuparán menos espacio en el disco, pero para abrir archivos comprimidos,
  necesitarás expandirlos, lo que implica que el procesador de la computadora deberá hacer cierto trabajo
  adicional.<br>
  Después de un cierto tiempo de procesamiento, deberíamos ver que la etiqueta en la partición indica Healthy
  (Correcto).<br>
  Para manipular discos desde la CLI, veremos en profundidad una herramienta llamada <strong>Diskpart</strong>.
  Diskpart es una herramienta basada en terminal, creada para administrar discos directamente desde la línea de
  comandos. Luego, para iniciar Diskpart, todo lo que tenemos que hacer es abrir un símbolo del sistema —en este
  caso, command.exe— y escribir Diskpart en él.<br>
  Puedes listar los discos actuales en el sistema escribiendo "<strong>list disk</strong>". A continuación,
  identificamos el disco que queremos formatear. Luego podemos seleccionarlo con <strong>select disk</strong>
  <strong>1</strong>. Ahora limpiaremos el disco con el comando <strong>clean</strong>, que eliminará todo el
  formato de particiones o volúmenes del disco. Con el disco limpio, ahora necesitamos crearle una partición. Esto
  puede hacerse con el comando <strong>create partition primary</strong> que creará una partición en blanco para
  nuestro sistema de archivos. Luego, vamos a seleccionar la partición con <strong>select partition 1</strong>. Y
  ahora, con solo escribir <strong>active</strong>, la marcaremos como activa.<br>
  El siguiente paso es formatear el disco con el sistema de archivos NTFS. Podemos hacerlo ejecutando este comando
  en el aviso de Diskpart: <strong>format FS=NTFS label="my-thumb-drive" quick</strong>. FS (por "archivo de
  sistema") NTFS y luego la etiqueta (label). Y luego el tipo de formato, vamos a querer hacerlo rápido (quick).
  Este comando formateará la unidad portátil con NTFS en modo rápido, lo que ya hablamos antes, y le dimos el
  nombre "My thumb drive".<br>
  <a href=
  "https://support.microsoft.com/en-us/help/140365/default-cluster-size-for-ntfs-fat-and-exfat">https://support.microsoft.com/en-us/help/140365/default-cluster-size-for-ntfs-fat-and-exfat</a><br>

  <a href=
  "https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-vista/cc766465(v=ws.10)?redirectedfrom=MSDN">
  https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-vista/cc766465(v=ws.10)?redirectedfrom=MSDN</a><br>


  <a href=
  "https://www.top-password.com/blog/format-hard-drive-using-powershell/">https://www.top-password.com/blog/format-hard-drive-using-powershell/</a><br>

  <a name="h3-3" id="h3-3"></a>
  <h3><strong>Linux: Partición de disco y formateo de un sistema de archivos</strong></h3>
  En Linux, hay algunas herramientas de línea de comandos de particionado diferentes que podemos usar. Una que
  soporta tanto el particionamiento MBR como el GPT es la herramienta parted. Antes de hacerlo, ejecutemos un
  comando para mostrar qué discos están conectados al ordenador usando el modo de línea de comandos. Podemos hacer
  esto ejecutando el comando <strong>sudo parted - l</strong>. Esto lista los discos que están conectados a
  nuestro ordenador.<br>
  Repasemos rápidamente lo que dice esta salida. Aquí podemos ver que la tabla de particiones está listada como
  gpt. El campo de número corresponde al número de particiones del disco. Podemos ver que hay tres particiones.
  Como este disco es /dev/sda, la primera partición corresponderá a /dev/sda 1 y la segunda a /dev/sda 2 etc. El
  campo de inicio es donde comienza la partición en el disco. Para esta primera partición podemos ver que comienza
  en 1.049 kilobytes y termina en 538 megabytes. El campo siguiente nos muestra el tamaño de la partición. El
  siguiente campo nos dice qué sistema de archivos está en la partición. Luego, tenemos el nombre y finalmente,
  podemos ver algunas banderas que están asociadas con esta partición.<br>
  Seleccionemos nuestro disco /dev/sdb y comencemos a particionarlo. Queremos tener mucho cuidado de seleccionar
  el disco correcto al particionar algo para no particionar accidentalmente el disco equivocado. Vamos a usar el
  modo interactivo de parted ejecutando <strong>sudo parted /dev/sdb</strong>. Ahora estamos en la herramienta
  parted. Desde aquí, podemos ejecutar más comandos. Si queremos salir de esta herramienta y volver al shell
  entonces sólo tenemos que usar el comando <em>quit</em>. Voy a ejecutar print para ver este disco una vez más.
  Dice que tenemos una etiqueta de disco no reconocida. Necesitaremos establecer una etiqueta de disco con el
  comando mklabel. Ya que queremos usar <em>la tabla de particiones</em> gpt usemos este comando. <strong>Mklabel
  gpt</strong>. Veamos de nuevo el estado de nuestro disco para hacer que podamos usar un comando print. Aquí
  podemos ver la información del disco para el disco /dev/sdb seleccionado. Ahora dice que tenemos la tabla de
  particiones gpt. Dentro de la herramienta parted vamos a usar el comando mkpart. El comando mkpart necesita
  tener la siguiente información, qué <em>tipo de partición</em> queremos hacer, qué sistema de ficheros queremos
  formatear, y el inicio y el final del disco así: <strong>mkpart primary ext4 1MiB 5GiB</strong><br>
  El tipo de partición sólo tiene sentido para las tablas de partición mbr. Recuerde que mbr usa particiones
  primarias, extendidas y lógicas. Ya que estamos formateando esto usando gpt, vamos a usar primary como el tipo
  de partición. El punto de inicio aquí es un mebibyte y el punto final es cinco gibytes. Así que nuestra
  partición es esencialmente cinco gibytes. Recuerde desde el curso anterior, que los tamaños de los datos se han
  referido durante mucho tiempo de dos maneras diferentes, usando la medida exacta de los datos y la medida
  estimada de los datos. Recuerda que un kibyte es en realidad 1,024 bytes mientras que un kilobyte es 1,000
  bytes. No hemos tenido que preocuparnos por esta distinción antes. Algunos sistemas operativos a veces miden un
  kilobyte como 1.024 bytes, lo cual es confuso, pero cuando se trata de almacenamiento de datos queremos
  asegurarnos de que estamos utilizando las medidas precisas para no desperdiciar un valioso espacio de
  almacenamiento.<br>
  Optemos por usar mebibyte y gibibyte en nuestra partición. A continuación vamos a formatear la partición con el
  sistema de archivos usando mkfs. Así que voy a quit, <strong>sudo mkfs -t ext4 /dev/sdb1</strong>.<br>
  <a href=
  "https://rm-rf.es/gestion-de-particiones-con-parted-en-linux/">https://rm-rf.es/gestion-de-particiones-con-parted-en-linux/</a><br>

  <a href="https://linuxhint.com/parted_linux/">https://linuxhint.com/parted_linux/</a><br>
  <a name="h3-4" id="h3-4"></a>
  <h3><strong>Linux: Montaje y desmontaje de un sistema de archivos</strong></h3>
  Para comenzar a interactuar con el disco, necesitamos montar el sistema de archivos en el directorio.<br>
  Detengámonos en la ubicación de nuestra partición con sudo parted -l. Muy bien, puedo ver que la partición a la
  que queremos acceder es /dev/sdb1. Ya creé un directorio bajo el directorio raíz llamado my_usb. Vamos a
  intentarlo. Entonces: <strong>sudo mount /dev/sdb1 /my_usb/</strong>. Ahora, si vamos a my_usb, podemos empezar
  a leer y escribir en el nuevo sistema de archivos.<br>
  También podemos desmontar el sistema de archivos de manera similar usando el comando umount. Desmontar es lo
  contrario de montar un disco. Así que ahora vamos a desmontar el sistema de archivos. Puedo usar <strong>sudo
  umount /my_usb</strong>, o sudo umount /dev/sdb1. Ambas servirán para desmontar un sistema de archivos.<br>
  Siempre asegúrate de desmontar un sistema de archivos de una unidad antes de desconectarla físicamente. En el
  caso de una unidad USB, podemos encontrarnos con algunos errores interesantes del sistema de archivos si no lo
  hacemos.<br>
  Además, ten en cuenta que cuando usamos el comando mount para montar un sistema de archivos en un directorio,
  una vez que apagamos la computadora, el punto de montaje desaparece. Sin embargo, podemos montar permanentemente
  un disco si necesitáramos cargarlo automáticamente cuando la computadora se inicia. Para ello, tenemos que
  modificar un archivo llamado /etc/fstab. Si lo abrimos ahora, verás una lista de ID de dispositivos únicos, sus
  puntos de montaje, qué tipo de sistema de archivos son, más un poco de información adicional. Si queremos montar
  automáticamente sistemas de archivos cuando la computadora se inicia, solo hay que agregar una entrada similar a
  lo que se lista aquí. El primer campo que necesitamos agregar en /etc/fstab es el UUID o ID universal único de
  nuestra unidad USB. Para obtener el UUID de nuestros dispositivos, podemos usar este comando: sudo blkid. Nos
  mostrará el UUID para los ID de dispositivo de bloqueo ID, conocidos también como ID de dispositivo de
  almacenamiento.<br>
  <a href="https://es.wikipedia.org/wiki/Fstab">https://es.wikipedia.org/wiki/Fstab</a><br>
  <a name="h3-5" id="h3-5"></a>
  <h3><strong>Windows: Swap</strong></h3>
  La memoria virtual es la forma en que nuestro SO proporciona memoria física disponible en nuestra computadora
  (como RAM) a las aplicaciones que se ejecutan en ella. Lo hace creando un mapeo de direcciones virtuales a
  físicas. Esto le simplifica las cosas al programa que necesita acceder a la memoria, ya que no tiene que
  preocuparse por las porciones de memoria qué otros programas podrían estar usando. Tampoco tiene que rastrear
  dónde se encuentran, en la RAM, los datos que está usando. La memoria virtual también nos permite que nuestra
  computadora use más memoria de la que físicamente tenemos instalada. Para ello, dedica un área del disco duro
  para usar una base de almacenamiento para bloques de datos llamados páginas. Cuando una aplicación no usa una
  página de datos en particular, esta es expulsada, lo que significa que se copia fuera de la memoria, en el disco
  duro. Esto se debe a que el acceso a los datos en la memoria RAM es rápido, mucho más rápido que en el disco
  duro, en el que el espacio es un bien escaso. Debido a esto, el sistema operativo quiere mantener las páginas de
  datos de acceso más frecuente en la memoria RAM. Luego pone en el disco cosas que no se usaron por un tiempo. De
  esta manera, si un programa necesita una página a la que no se accede mucho, el sistema operativo todavía puede
  llegar a ella. Pero tiene que leerla del disco duro, lento en comparación, y volverla a poner en la memoria.<br>
  Windows usa un programa llamado Administrador de memoria (Memory Manager) para manejar la memoria virtual. Su
  trabajo es hacerse cargo de ese mapeo de memoria virtual a física para nuestros programas y gestionar la
  paginación. En Windows, las páginas guardadas en el disco se almacenan en un archivo oculto especial en la
  partición raíz de un volumen llamado pagefile.sys. Windows crea automáticamente archivos de paginación y usa el
  Administrador de memoria para copiar páginas de la memoria y leerlas según sea necesario.<br>
  Windows proporciona una forma de modificar el tamaño, la cantidad y la ubicación de los archivos de paginación a
  través de un applet del panel de control llamado Propiedades del sistema. Para acceder al applet Propiedades del
  sistema, abre el Panel de control, ve a la configuración System and Security (Sistema y seguridad), y haz clic
  en System (Sistema). Cuando estés en el panel System (Sistema), puedes abrir Advanced system settings
  (Configuración avanzada del sistema) en el menú de la izquierda. Elige la pestaña Advanced (Opciones avanzadas),
  luego haz clic en el botón Settings... (Configuración...) en la sección Performance (Rendimiento). Por último,
  haz clic en la pestaña Advanced (Opciones avanzadas) y deberías ver una sección llamada Virtual memory (Memoria
  virtual) que muestra el tamaño del archivo de paginación. Si haces clic en el botón Change... (Cambiar...),
  puedes anular los valores predeterminados que proporciona Windows para establecer el tamaño del archivo de
  paginación y agregar archivos de paginación a otras unidades en la computadora.<br>
  <a href=
  "https://en.wikipedia.org/wiki/Paging#Windows_NT">https://en.wikipedia.org/wiki/Paging#Windows_NT</a><br>
  <a href=
  "https://docs.microsoft.com/en-us/windows/client-management/determine-appropriate-page-file-size">https://docs.microsoft.com/en-us/windows/client-management/determine-appropriate-page-file-size</a><br>

  <a name="h3-6" id="h3-6"></a>
  <h3><strong>Linux: Swap</strong></h3>
  En Linux, el área exclusiva del disco duro que se usa para la memoria virtual se conoce como espacio de
  intercambio.<br>
  Entonces: <strong>sudo mkswap /dev</strong>, y nuestra nueva partición de intercambio está en /dev/sdb2. Por
  último, hay que ejecutar un comando más para habilitar el intercambio en el dispositivo, swapon. Entonces:
  <strong>sudo swapon dev/sdb2</strong>. Si queremos montar automáticamente el espacio de intercambio cada vez que
  el equipo se inicia, agregamos una entrada de intercambio al archivo /etc fstab como hicimos antes.<br>
  <a href=
  "https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007">
  https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/installation_guide/s2-diskpartrecommend-ppc#id4394007</a><br>

  <a name="h3-7" id="h3-7"></a>
  <h3><strong>Windows: Archivos</strong></h3>
  Cuando hablamos de datos, nos referimos al contenido real del archivo, como un documento de texto que guardamos
  en nuestros discos duros. El metadato del archivo incluye todo lo demás, como el propietario del archivo, los
  permisos, el tamaño del archivo, su ubicación en el disco duro, etc.<br>
  NTFS usa algo llamado tabla maestra de archivos, o MFT, para mantener todo en orden. Cada archivo en un volumen
  tiene, al menos, una entrada en la MFT, incluida la propia MFT. Por lo general, hay una correspondencia uno a
  uno entre los archivos y los registros MFT. Pero si un archivo tiene muchos atributos, podría haber más de un
  registro para representarlo.<br>
  <a href=
  "https://docs.microsoft.com/en-us/windows/win32/fileio/master-file-table">https://docs.microsoft.com/en-us/windows/win32/fileio/master-file-table</a><br>

  Cuando creas archivos en un sistema de archivos NTFS, las entradas se agregan a la MFT. Cuando los archivos se
  borran, sus entradas en la MFT se marcan como "libres" para que se puedan volver a usar. Una parte importante de
  la entrada de un archivo en la MFT es un identificador llamado "número de registro del archivo". Es el índice de
  la entrada de archivos en la MFT.<br>
  Un acceso directo es solo otro archivo y otra entrada en la MFT. Pero tiene una referencia a algún destino para
  que, cuando lo abras, te pueda llevar allí. Además de crear accesos directos como formas de acceder a otros
  archivos, NTFS proporciona otras dos formas mediante vínculos físicos y simbólicos.<br>
  Los vínculos simbólicos son como accesos directos, pero al nivel del sistema de archivos. Cuando creas un
  vínculo simbólico, creas una entrada en la MFT que apunta al nombre de otra entrada o de otro archivo. Esto
  podría parecer simplemente otra forma de crear un acceso directo, pero los vínculos simbólicos tienen una
  diferencia clave. El sistema operativo los trata como sustitutos del archivo al que están vinculados en casi
  todas las formas significativas. Puedes crear vínculos simbólicos con el programa mklink desde el símbolo del
  sistema.<br>
  <a href=
  "https://docs.microsoft.com/es-es/windows/win32/fileio/creating-symbolic-links?redirectedfrom=MSDN">https://docs.microsoft.com/es-es/windows/win32/fileio/creating-symbolic-links?redirectedfrom=MSDN</a><br>

  Hay otro tipo de vínculo que vale la pena mencionar, llamado vínculo físico. Cuando creas un vínculo físico en
  NTFS, se agrega una entrada a la MFT que apunta al número de registro del archivo vinculado, no al nombre del
  archivo. Esto significa que el nombre de archivo del objetivo puede cambiar y el vínculo físico todavía seguirá
  apuntando a él. Puedes crear vínculos físicos de forma similar a los vínculos simbólicos, pero con la opción /H
  .<br>
  <a href=
  "https://docs.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions">https://docs.microsoft.com/en-us/windows/win32/fileio/hard-links-and-junctions</a><br>

  <a name="h3-8" id="h3-8"></a>
  <h3><strong>Linux: Archivos</strong></h3>
  En Linux, los metadatos y los archivos se organizan en una estructura llamada inodo. Los inodos son similares a
  los registros MFT del NFTS de Windows. Almacenamos inodos en una tabla de inodos y nos ayudan a gestionar los
  archivos en nuestro sistema de archivos. El inodo en sí no almacena la fecha del archivo ni su nombre, pero
  almacena todo lo demás sobre un archivo.<br>
  A los accesos directos en Linux los llamamos softlinks o symlinks. Los softlinks nos permiten enlazar a otro
  archivo mediante un nombre de archivo.<br>
  El otro tipo de enlace que encontramos en Linux son los hardlinks. De manera similar a Windows, los hardlinks no
  apuntan a un archivo. En Linux, enlazan a otro inodo almacenado en una tabla de inodos en el sistema de
  archivos. Básicamente, cuando estás creando un hardlink, estás apuntando a una ubicación física en el disco o,
  más específicamente, en el sistema de archivos.<br>
  Para crear un softlink, podemos ejecutar el comando <strong>ln</strong> con el indicador -s para "softlink".<br>
  Para crear un hardlink, podemos ejecutar el comando ln sin la -s, para especificar un hardlink.<br>
  Los hardlinks son geniales si necesitas guardar el mismo archivo en diferentes lugares, pero no quieres ocupar
  nada de espacio adicional en el volumen. Esto es porque todos los hardlinks apuntan al mismo espacio en el
  volumen. Podrías usar softlinks para hacer lo mismo. Pero ¿y si moviste un archivo, deshiciste el softlink y
  olvidaste todos los demás lugares donde lo usaste? Todos los demás softlinks también quedarían deshechos y
  limpiar todo puede llevarte cierto tiempo.<br>
  <a name="h3-9" id="h3-9"></a>
  <h3><strong>Windows: Uso del disco</strong></h3>
  Para comprobar el uso del disco, puedes abrir la utilidad de Administración de equipos (Computer Management).
  Luego, ve a la consola Disk Management (Administración de discos). Desde allí, haz clic derecho en la partición
  que te interesa y seleccione Properties (Propiedades). Esto abrirá la pestaña General, donde puedes ver el
  espacio utilizado y el espacio libre en el disco.<br>
  Además de utilizar esta interfaz gráfica de usuario para comprobar el uso del disco, Windows proporciona una
  utilidad de línea de comandos llamada Disk Usage (DU) como parte de su oferta de herramientas internas del
  sistema. Esa utilidad DU puede imprimir el uso de un disco dado y decirte cuántos archivos tiene.<br>
  <a href=
  "https://docs.microsoft.com/en-us/sysinternals/downloads/du">https://docs.microsoft.com/en-us/sysinternals/downloads/du</a><br>

  En la misma pestaña de la consola de administración de discos, tal vez notes un botón que dice Disk Cleanup
  (Limpieza del disco). Si presionas este botón, Windows ejecutará un programa llamado CleanManager.exe que hará
  un poco de limpieza en tu disco duro para tratar de liberar algo de espacio. Esta limpieza incluye cosas como
  eliminar archivos temporales, comprimir archivos viejos y raramente usados, limpiar registros y vaciar la
  papelera de reciclaje.<br>
  La idea subyacente a la desfragmentación del disco es tomar todos los archivos almacenados en un disco dado y
  reorganizarlos en ubicaciones vecinas. Tener los archivos ordenados de esta manera facilitará la rotación de los
  discos duros que usan un brazo de accionamiento para escribir y leer desde un disco giratorio. El cabezal del
  brazo de accionamiento se desplazará menos para leer los datos que necesita.<br>
  Para este tipo de unidades SSD, el sistema operativo puede utilizar un proceso llamado Trim para recuperar
  partes no utilizadas del disco de estado sólido.<br>
  Para iniciar una desfragmentación manual, abre el Desfragmentador de discos incluido en el SO.<br>
  <a name="h3-10" id="h3-10"></a>
  <h3><strong>Linux: Uso del disco</strong></h3>
  En la última lección, aprendimos a ver la utilización del disco en tu computadora con Windows. En Linux, lo
  hacemos con el comando <strong>du -h</strong>. El comando du o "uso del disco" nos muestra el uso del disco de
  un directorio específico. Si no especificas un directorio, irá de manera predeterminada al disco actual.<br>
  Otro comando que puedes usar si quieres saber cuánto espacio libre tienes en tu máquina es el comando
  <strong>df</strong>, o "disco libre".<br>
  <a href=
  "https://www.howtogeek.com/115229/htg-explains-why-linux-doesnt-need-defragmenting/">https://www.howtogeek.com/115229/htg-explains-why-linux-doesnt-need-defragmenting/</a><br>

  <a name="h3-11" id="h3-11"></a>
  <h3><strong>Windows: Reparación del sistema de archivos</strong></h3>
  Cuando leemos o escribimos algo en una unidad, en realidad primero ponemos eso en un búfer o memoria caché. Un
  búfer de datos es una región de la RAM que se usa para almacenar datos temporalmente mientras se los está
  desplazando. Entonces, cuando copias algo de tu SO a tu unidad USB, primero se copia en un búfer de datos porque
  la RAM trabaja más rápido que los discos duros. Si no desmontas correctamente un sistema de archivos y no le das
  tiempo suficiente a tu búfer para que termine de mover los datos, corres el riesgo de corrupción de datos.<br>
  El sistema de archivos NTFS tiene algunas características avanzadas integradas que pueden ayudar a minimizar el
  peligro de corrupción además de intentar una recuperación cuando el sistema de archivos se daña. Una de estas
  características, a través de un proceso llamado registro en diario, registra los cambios realizados en los
  metadatos de un archivo en un archivo llamado "registro NTFS". Al registrar estos cambios, NTFS crea un
  historial de las medidas tomadas. Esto significa que puede mirar el registro para ver cuál debería ser el estado
  actual del sistema. Si un bloqueo o un error provocan la corrupción, el sistema de archivos puede iniciar el
  proceso de recuperación que usará ese registro para asegurarse de que el sistema está en un estado
  coherente.<br>
  Además del registro en diario, NTFS y Windows implementan algo llamado recuperación automática. Como puedes
  suponer por el nombre, el mecanismo de recuperación automática hace modificaciones en problemas menores y
  corrupciones en el disco automáticamente, en segundo plano. Hace esto mientras Windows se está ejecutando, por
  lo que no es necesario reiniciar. Si deseas comprobar el estado del proceso de recuperación automática en tu
  computadora, puedes abrir un símbolo de sistema como administrador y usar la herramienta fsutil, así. Fsutil
  repair query C.<br>
  Por último, cuando las cosas se ponen muy mal y hay una corrupción seria o catastrófica del disco, como sectores
  defectuosos, fallas de disco y más, puedes recurrir a la utilidad chkdsk de NTFS. Gracias a las características
  de recuperación incorporadas en NTFS no siempre es necesario ejecutar chkdsk. Pero está disponible en caso de
  emergencia. Para ejecutar chkdsk manualmente, puedes abrir un símbolo de sistema como administrador y escribir
  chkdsk en la línea de comandos. De forma predeterminada, chkdsk se ejecutará en modo de solo lectura. Te daré un
  informe sobre la salud del disco, pero no hará modificaciones o reparaciones en él. Puedes indicarle a chkdsk
  que repare cualquier problema que encuentre con el indicador /F. También puedes especificar la unidad que
  quieres verificar.<br>
  Si el sistema operativo detecta que algunos datos se corrompieron o que el disco tiene un sector con fallas,
  configurará un bit en un archivo de metadatos en el volumen que indica que hay corrupción. Cuando el sistema se
  inicie, la utilidad chkdsk comprobará este bit. Si está configurado, se ejecutará y tratará de reparar la
  corrupción reconstruyendo los bits dañados del sistema de archivos desde el registro NTFS.<br>
  <a name="h3-12" id="h3-12"></a>
  <h3><strong>Linux: Reparación del sistema de archivos</strong></h3>
  Para tratar de reparar un sistema de archivos manualmente en Linux, también puedes utilizar el comando fsck o
  "verificar sistema de archivos". Sólo asegúrate de que el sistema de archivos no esté montado. Algo más para
  destacar es que, en algunas versiones de Linux, fsck en realidad se ejecuta en tu computadora cuando la inicias
  para comprobar si hay problemas e intenta reparar automáticamente el sistema de archivos.<br>
  <a href="https://es.wikipedia.org/wiki/Fsck">https://es.wikipedia.org/wiki/Fsck</a>
  <p align="center"><img src="images/home.png" height="22" width="22"> <a href="index.html">Índice</a></p>
</body>
</html>
